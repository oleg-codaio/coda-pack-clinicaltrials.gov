/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/studies": {
    /**
     * Studies
     * @description Returns data of studies matching query and filter parameters. The studies are returned page by page.
     * If response contains `nextPageToken`, use its value in `pageToken` to get next page.
     * The last page will not contain `nextPageToken`. A page may have empty `studies` array.
     * Request for each subsequent page **must** have the same parameters as for the first page, except
     * `countTotal`, `pageSize`, and `pageToken` parameters.
     *
     * If neither queries nor filters are set, all studies will be returned.
     * If any query parameter contains only NCT IDs (comma- and/or space-separated), filters are ignored.
     *
     * `query.*` parameters are in [Essie expression syntax](https://classic.clinicaltrials.gov/api/gui/ref/syntax).
     *
     * `filter.*` and `postFilter.*` parameters have same effect as there is no aggregation calculation.
     * Both are available just to simplify applying parameters from search request.
     *
     * Note: When trying JSON format in your browser, do not set too large `pageSize` parameter, if `fields` is
     * unlimited. That may return too much data for the browser to parse and render.
     */
    get: operations["listStudies"];
  };
  "/studies/{nctId}": {
    /**
     * Single Study
     * @description Returns data of a single study.
     */
    get: operations["fetchStudy"];
  };
  "/studies/metadata": {
    /**
     * Data Model Fields
     * @description Returns study data model fields.
     */
    get: operations["studiesMetadata"];
  };
  "/studies/search-areas": {
    /**
     * Search Areas
     * @description Search Docs and their Search Areas.
     */
    get: operations["searchAreas"];
  };
  "/studies/enums": {
    /**
     * Enums
     * @description Returns enumeration types and their values.
     *
     * Every item of the returning array represents enum type and contains the following properties:
     * * `type` - enum type name
     * * `pieces` - array of names of all data pieces having the enum type
     * * `values` - all available values of the enum; every item contains the following properties:
     *   * `value` - data value
     *   * `legacyValue` - data value in legacy API
     *   * `exceptions` - map from data piece name to legacy value when different from `legacyValue`
     *     (some data pieces had special enum values in legacy API)
     */
    get: operations["enums"];
  };
  "/stats/size": {
    /**
     * Study Sizes
     * @description Statistics of study JSON sizes.
     */
    get: operations["sizeStats"];
  };
  "/stats/field/values": {
    /**
     * Field Values
     * @description Value statistics of the study leaf fields.
     */
    get: operations["fieldValuesStats"];
  };
  "/stats/field/sizes": {
    /**
     * List Field Sizes
     * @description Sizes of list/array fields.
     *
     * To search studies by a list field size, use `AREA[FieldName:size]` search operator.
     * For example, [AREA\[Phase:size\] 2](https://clinicaltrials.gov/search?term=AREA%5BPhase:size%5D%202)
     * query finds studies with 2 phases.
     */
    get: operations["listFieldSizesStats"];
  };
  "/version": {
    /**
     * Version
     * @description API and data versions.
     *
     * API version follows [Semantic Versioning 2.0.0 Schema](https://semver.org/spec/v2.0.0.html).
     * Data version is UTC timestamp in `yyyy-MM-dd'T'HH:mm:ss` format.
     */
    get: operations["version"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    FieldNode: {
      altPieceNames?: string[];
      children?: components["schemas"]["FieldNode"][];
      dedLink?: string;
      definition?: string;
      historicOnly?: boolean;
      indexedOnly?: boolean;
      isEnum?: boolean;
      /** Format: int32 */
      maxChars?: number;
      name: string;
      nested?: boolean;
      piece: string;
      rules?: string;
      sourceType: string;
      synonyms?: boolean;
      title?: string;
      type: string;
    };
    FieldNodeList: components["schemas"]["FieldNode"][];
    SearchDocument: {
      areas: components["schemas"]["SearchArea"][];
      name: string;
    };
    SearchArea: {
      name: string;
      param?: string;
      parts: components["schemas"]["SearchPart"][];
      uiLabel?: string;
    };
    SearchPart: {
      isEnum: boolean;
      isSynonyms: boolean;
      pieces: string[];
      type: string;
      /** Format: float */
      weight: number;
    };
    SearchDocumentList: components["schemas"]["SearchDocument"][];
    EnumInfo: {
      pieces: string[];
      type: string;
      values: components["schemas"]["EnumItem"][];
    };
    EnumItem: {
      exceptions?: Record<string, never>;
      legacyValue: string;
      value: string;
    };
    EnumInfoList: components["schemas"]["EnumInfo"][];
    GzipStats: {
      /** Format: int32 */
      averageSizeBytes: number;
      largestStudies: components["schemas"]["StudySize"][];
      percentiles: Record<string, never>;
      ranges: components["schemas"]["DistItem"][];
      /** Format: int32 */
      totalStudies: number;
    };
    StudySize: {
      id: string;
      /** Format: int32 */
      sizeBytes: number;
    };
    DistItem: {
      sizeRange: string;
      /** Format: int32 */
      studiesCount: number;
    };
    ListSizes: {
      field: string;
      maxSize?: number;
      minSize?: number;
      piece: string;
      topSizes?: components["schemas"]["ListSize"][];
      /** Format: int64 */
      uniqueSizesCount: number;
    };
    ListSize: {
      size: number;
      /** Format: int32 */
      studiesCount: number;
    };
    ListSizesList: components["schemas"]["ListSizes"][];
    EnumStats: {
      field: string;
      /** Format: int32 */
      missingStudiesCount: number;
      piece: string;
      topValues?: components["schemas"]["ValueCount"][];
      type: components["schemas"]["FieldStatsType"];
      /** Format: int64 */
      uniqueValuesCount: number;
    };
    ValueCount: {
      /** Format: int32 */
      studiesCount: number;
      value: string;
    };
    /** @enum {string} */
    FieldStatsType: "ENUM" | "STRING" | "DATE" | "INTEGER" | "NUMBER" | "BOOLEAN";
    StringStats: {
      field: string;
      longest?: components["schemas"]["LongestString"];
      /** Format: int32 */
      missingStudiesCount: number;
      piece: string;
      topValues?: components["schemas"]["ValueCount"][];
      type: components["schemas"]["FieldStatsType"];
      /** Format: int64 */
      uniqueValuesCount: number;
    };
    LongestString: {
      /** Format: int32 */
      length: number;
      nctId: string;
      value: string;
    };
    DateStats: {
      field: string;
      formats: string[];
      max?: string;
      min?: string;
      /** Format: int32 */
      missingStudiesCount: number;
      piece: string;
      type: components["schemas"]["FieldStatsType"];
    };
    IntegerStats: {
      /** Format: double */
      avg?: number;
      field: string;
      /** Format: int64 */
      max?: number;
      /** Format: int64 */
      min?: number;
      /** Format: int32 */
      missingStudiesCount: number;
      piece: string;
      type: components["schemas"]["FieldStatsType"];
    };
    NumberStats: {
      /** Format: double */
      avg?: number;
      field: string;
      /** Format: double */
      max?: number;
      /** Format: double */
      min?: number;
      /** Format: int32 */
      missingStudiesCount: number;
      piece: string;
      type: components["schemas"]["FieldStatsType"];
    };
    BooleanStats: {
      /** Format: int32 */
      falseCount: number;
      field: string;
      /** Format: int32 */
      missingStudiesCount: number;
      piece: string;
      /** Format: int32 */
      trueCount: number;
      type: components["schemas"]["FieldStatsType"];
    };
    Version: {
      apiVersion: string;
      dataTimestamp?: string;
    };
    PagedStudies: {
      nextPageToken?: string;
      studies: components["schemas"]["StudyList"];
      /** Format: int32 */
      totalCount?: number;
    };
    Study: {
      protocolSection?: components["schemas"]["ProtocolSection"];
      resultsSection?: components["schemas"]["ResultsSection"];
      annotationSection?: components["schemas"]["AnnotationSection"];
      documentSection?: components["schemas"]["DocumentSection"];
      derivedSection?: components["schemas"]["DerivedSection"];
      hasResults?: boolean;
    };
    ProtocolSection: {
      identificationModule?: components["schemas"]["IdentificationModule"];
      statusModule?: components["schemas"]["StatusModule"];
      sponsorCollaboratorsModule?: components["schemas"]["SponsorCollaboratorsModule"];
      oversightModule?: components["schemas"]["OversightModule"];
      descriptionModule?: components["schemas"]["DescriptionModule"];
      conditionsModule?: components["schemas"]["ConditionsModule"];
      designModule?: components["schemas"]["DesignModule"];
      armsInterventionsModule?: components["schemas"]["ArmsInterventionsModule"];
      outcomesModule?: components["schemas"]["OutcomesModule"];
      eligibilityModule?: components["schemas"]["EligibilityModule"];
      contactsLocationsModule?: components["schemas"]["ContactsLocationsModule"];
      referencesModule?: components["schemas"]["ReferencesModule"];
      ipdSharingStatementModule?: components["schemas"]["IpdSharingStatementModule"];
    };
    ResultsSection: {
      participantFlowModule?: components["schemas"]["ParticipantFlowModule"];
      baselineCharacteristicsModule?: components["schemas"]["BaselineCharacteristicsModule"];
      outcomeMeasuresModule?: components["schemas"]["OutcomeMeasuresModule"];
      adverseEventsModule?: components["schemas"]["AdverseEventsModule"];
      moreInfoModule?: components["schemas"]["MoreInfoModule"];
    };
    AnnotationSection: {
      annotationModule?: components["schemas"]["AnnotationModule"];
    };
    DocumentSection: {
      largeDocumentModule?: components["schemas"]["LargeDocumentModule"];
    };
    DerivedSection: {
      miscInfoModule?: components["schemas"]["MiscInfoModule"];
      conditionBrowseModule?: components["schemas"]["BrowseModule"];
      interventionBrowseModule?: components["schemas"]["BrowseModule"];
    };
    IdentificationModule: {
      nctId?: string;
      nctIdAliases?: string[];
      orgStudyIdInfo?: components["schemas"]["OrgStudyIdInfo"];
      secondaryIdInfos?: components["schemas"]["SecondaryIdInfo"][];
      briefTitle?: string;
      officialTitle?: string;
      acronym?: string;
      organization?: components["schemas"]["Organization"];
    };
    StatusModule: {
      statusVerifiedDate?: components["schemas"]["PartialDate"];
      overallStatus?: components["schemas"]["Status"];
      lastKnownStatus?: components["schemas"]["Status"];
      delayedPosting?: boolean;
      whyStopped?: string;
      expandedAccessInfo?: components["schemas"]["ExpandedAccessInfo"];
      startDateStruct?: components["schemas"]["PartialDateStruct"];
      primaryCompletionDateStruct?: components["schemas"]["PartialDateStruct"];
      completionDateStruct?: components["schemas"]["PartialDateStruct"];
      /** Format: date */
      studyFirstSubmitDate?: string;
      /** Format: date */
      studyFirstSubmitQcDate?: string;
      studyFirstPostDateStruct?: components["schemas"]["DateStruct"];
      /** Format: date */
      resultsFirstSubmitDate?: string;
      /** Format: date */
      resultsFirstSubmitQcDate?: string;
      resultsFirstPostDateStruct?: components["schemas"]["DateStruct"];
      /** Format: date */
      dispFirstSubmitDate?: string;
      /** Format: date */
      dispFirstSubmitQcDate?: string;
      dispFirstPostDateStruct?: components["schemas"]["DateStruct"];
      /** Format: date */
      lastUpdateSubmitDate?: string;
      lastUpdatePostDateStruct?: components["schemas"]["DateStruct"];
    };
    SponsorCollaboratorsModule: {
      responsibleParty?: components["schemas"]["ResponsibleParty"];
      leadSponsor?: components["schemas"]["Sponsor"];
      collaborators?: components["schemas"]["Sponsor"][];
    };
    OversightModule: {
      oversightHasDmc?: boolean;
      isFdaRegulatedDrug?: boolean;
      isFdaRegulatedDevice?: boolean;
      isUnapprovedDevice?: boolean;
      isPpsd?: boolean;
      isUsExport?: boolean;
      fdaaa801Violation?: boolean;
    };
    DescriptionModule: {
      briefSummary?: string;
      detailedDescription?: string;
    };
    ConditionsModule: {
      conditions?: string[];
      keywords?: string[];
    };
    DesignModule: {
      studyType?: components["schemas"]["StudyType"];
      nPtrsToThisExpAccNctId?: number;
      expandedAccessTypes?: components["schemas"]["ExpandedAccessTypes"];
      patientRegistry?: boolean;
      targetDuration?: string;
      phases?: components["schemas"]["Phase"][];
      designInfo?: components["schemas"]["DesignInfo"];
      bioSpec?: components["schemas"]["BioSpec"];
      enrollmentInfo?: components["schemas"]["EnrollmentInfo"];
    };
    ArmsInterventionsModule: {
      armGroups?: components["schemas"]["ArmGroup"][];
      interventions?: components["schemas"]["Intervention"][];
    };
    OutcomesModule: {
      primaryOutcomes?: components["schemas"]["Outcome"][];
      secondaryOutcomes?: components["schemas"]["Outcome"][];
      otherOutcomes?: components["schemas"]["Outcome"][];
    };
    EligibilityModule: {
      eligibilityCriteria?: string;
      healthyVolunteers?: boolean;
      sex?: components["schemas"]["Sex"];
      genderBased?: boolean;
      genderDescription?: string;
      minimumAge?: string;
      maximumAge?: string;
      stdAges?: components["schemas"]["StandardAge"][];
      studyPopulation?: string;
      samplingMethod?: components["schemas"]["SamplingMethod"];
    };
    ContactsLocationsModule: {
      centralContacts?: components["schemas"]["Contact"][];
      overallOfficials?: components["schemas"]["Official"][];
      locations?: components["schemas"]["Location"][];
    };
    ReferencesModule: {
      references?: components["schemas"]["Reference"][];
      seeAlsoLinks?: components["schemas"]["SeeAlsoLink"][];
      availIpds?: components["schemas"]["AvailIpd"][];
    };
    OutcomeMeasuresModule: {
      outcomeMeasures?: components["schemas"]["OutcomeMeasure"][];
    };
    MoreInfoModule: {
      limitationsAndCaveats?: components["schemas"]["LimitationsAndCaveats"];
      certainAgreement?: components["schemas"]["CertainAgreement"];
      pointOfContact?: components["schemas"]["PointOfContact"];
    };
    AnnotationModule: {
      unpostedAnnotation?: components["schemas"]["UnpostedAnnotation"];
      violationAnnotation?: components["schemas"]["ViolationAnnotation"];
    };
    MiscInfoModule: {
      /** Format: date */
      versionHolder?: string;
      removedCountries?: string[];
      submissionTracking?: components["schemas"]["SubmissionTracking"];
      modelPredictions?: components["schemas"]["ModelPredictions"];
    };
    UnpostedAnnotation: {
      unpostedResponsibleParty?: string;
      unpostedEvents?: components["schemas"]["UnpostedEvent"][];
    };
    ViolationAnnotation: {
      violationEvents?: components["schemas"]["ViolationEvent"][];
    };
    SubmissionTracking: {
      /** Format: date */
      estimatedResultsFirstSubmitDate?: string;
      firstMcpInfo?: components["schemas"]["FirstMcpInfo"];
      submissionInfos?: components["schemas"]["SubmissionInfo"][];
    };
    ModelPredictions: {
      bmiLimits?: components["schemas"]["BmiLimits"];
    };
    BmiLimits: {
      minBmi?: number;
      maxBmi?: number;
    };
    EnrollmentInfo: {
      count?: number;
      type?: components["schemas"]["EnrollmentType"];
    };
    BioSpec: {
      retention?: components["schemas"]["BioSpecRetention"];
      description?: string;
    };
    SeeAlsoLink: {
      label?: string;
      url?: string;
    };
    FirstMcpInfo: {
      postDateStruct?: components["schemas"]["DateStruct"];
    };
    ExpandedAccessTypes: {
      individual?: boolean;
      intermediate?: boolean;
      treatment?: boolean;
    };
    Intervention: {
      type?: components["schemas"]["InterventionType"];
      name?: string;
      description?: string;
      armGroupLabels?: string[];
      otherNames?: string[];
    };
    SecondaryIdInfo: {
      id?: string;
      type?: components["schemas"]["SecondaryIdType"];
      domain?: string;
      link?: string;
    };
    AvailIpd: {
      id?: string;
      type?: string;
      url?: string;
      comment?: string;
    };
    LimitationsAndCaveats: {
      description?: string;
    };
    DateStruct: {
      /** Format: date */
      date?: string;
      type?: components["schemas"]["DateType"];
    };
    SubmissionInfo: {
      /** Format: date */
      releaseDate?: string;
      /** Format: date */
      unreleaseDate?: string;
      unreleaseDateUnknown?: boolean;
      /** Format: date */
      resetDate?: string;
      mcpReleaseN?: number;
    };
    ExpandedAccessInfo: {
      hasExpandedAccess?: boolean;
      nctId?: string;
      statusForNctId?: components["schemas"]["ExpandedAccessStatus"];
    };
    AdverseEventsModule: {
      frequencyThreshold?: string;
      timeFrame?: string;
      description?: string;
      allCauseMortalityComment?: string;
      eventGroups?: components["schemas"]["EventGroup"][];
      seriousEvents?: components["schemas"]["AdverseEvent"][];
      otherEvents?: components["schemas"]["AdverseEvent"][];
    };
    ViolationEvent: {
      type?: components["schemas"]["ViolationEventType"];
      description?: string;
      /** Format: date */
      creationDate?: string;
      /** Format: date */
      issuedDate?: string;
      /** Format: date */
      releaseDate?: string;
      /** Format: date */
      postedDate?: string;
    };
    ArmGroup: {
      label?: string;
      type?: components["schemas"]["ArmGroupType"];
      description?: string;
      interventionNames?: string[];
    };
    DesignInfo: {
      allocation?: components["schemas"]["DesignAllocation"];
      interventionModel?: components["schemas"]["InterventionalAssignment"];
      interventionModelDescription?: string;
      primaryPurpose?: components["schemas"]["PrimaryPurpose"];
      observationalModel?: components["schemas"]["ObservationalModel"];
      timePerspective?: components["schemas"]["DesignTimePerspective"];
      maskingInfo?: components["schemas"]["MaskingBlock"];
    };
    Organization: {
      fullName?: string;
      class?: components["schemas"]["AgencyClass"];
    };
    PointOfContact: {
      title?: string;
      organization?: string;
      email?: string;
      phone?: string;
      phoneExt?: string;
    };
    IpdSharingStatementModule: {
      ipdSharing?: components["schemas"]["IpdSharing"];
      description?: string;
      infoTypes?: components["schemas"]["IpdSharingInfoType"][];
      timeFrame?: string;
      accessCriteria?: string;
      url?: string;
    };
    OrgStudyIdInfo: {
      id?: string;
      type?: components["schemas"]["OrgStudyIdType"];
      link?: string;
    };
    ResponsibleParty: {
      type?: components["schemas"]["ResponsiblePartyType"];
      investigatorFullName?: string;
      investigatorTitle?: string;
      investigatorAffiliation?: string;
      oldNameTitle?: string;
      oldOrganization?: string;
    };
    CertainAgreement: {
      piSponsorEmployee?: boolean;
      restrictionType?: components["schemas"]["AgreementRestrictionType"];
      restrictiveAgreement?: boolean;
      otherDetails?: string;
    };
    UnpostedEvent: {
      type?: components["schemas"]["UnpostedEventType"];
      /** Format: date */
      date?: string;
      dateUnknown?: boolean;
    };
    Contact: {
      name?: string;
      role?: components["schemas"]["ContactRole"];
      phone?: string;
      phoneExt?: string;
      email?: string;
    };
    PartialDateStruct: {
      date?: components["schemas"]["PartialDate"];
      type?: components["schemas"]["DateType"];
    };
    Outcome: {
      measure?: string;
      description?: string;
      timeFrame?: string;
    };
    OutcomeMeasure: {
      type?: components["schemas"]["OutcomeMeasureType"];
      title?: string;
      description?: string;
      populationDescription?: string;
      reportingStatus?: components["schemas"]["ReportingStatus"];
      anticipatedPostingDate?: components["schemas"]["PartialDate"];
      paramType?: components["schemas"]["MeasureParam"];
      dispersionType?: string;
      unitOfMeasure?: string;
      calculatePct?: boolean;
      timeFrame?: string;
      typeUnitsAnalyzed?: string;
      denomUnitsSelected?: string;
      groups?: components["schemas"]["MeasureGroup"][];
      denoms?: components["schemas"]["Denom"][];
      classes?: components["schemas"]["MeasureClass"][];
      analyses?: components["schemas"]["MeasureAnalysis"][];
    };
    BaselineCharacteristicsModule: {
      populationDescription?: string;
      typeUnitsAnalyzed?: string;
      groups?: components["schemas"]["MeasureGroup"][];
      denoms?: components["schemas"]["Denom"][];
      measures?: components["schemas"]["BaselineMeasure"][];
    };
    Reference: {
      pmid?: string;
      type?: components["schemas"]["ReferenceType"];
      citation?: string;
      retractions?: components["schemas"]["Retraction"][];
    };
    ParticipantFlowModule: {
      preAssignmentDetails?: string;
      recruitmentDetails?: string;
      typeUnitsAnalyzed?: string;
      groups?: components["schemas"]["FlowGroup"][];
      periods?: components["schemas"]["FlowPeriod"][];
    };
    LargeDocumentModule: {
      noSap?: boolean;
      largeDocs?: components["schemas"]["LargeDoc"][];
    };
    Location: {
      facility?: string;
      status?: components["schemas"]["RecruitmentStatus"];
      city?: string;
      state?: string;
      zip?: string;
      country?: string;
      contacts?: components["schemas"]["Contact"][];
      geoPoint?: components["schemas"]["GeoPoint"];
    };
    Sponsor: {
      name?: string;
      class?: components["schemas"]["AgencyClass"];
    };
    BrowseModule: {
      meshes?: components["schemas"]["Mesh"][];
      ancestors?: components["schemas"]["Mesh"][];
      browseLeaves?: components["schemas"]["BrowseLeaf"][];
      browseBranches?: components["schemas"]["BrowseBranch"][];
    };
    Official: {
      name?: string;
      affiliation?: string;
      role?: components["schemas"]["OfficialRole"];
    };
    BrowseLeaf: {
      id?: string;
      name?: string;
      asFound?: string;
      relevance?: components["schemas"]["BrowseLeafRelevance"];
    };
    MaskingBlock: {
      masking?: components["schemas"]["DesignMasking"];
      maskingDescription?: string;
      whoMasked?: components["schemas"]["WhoMasked"][];
    };
    EventGroup: {
      id?: string;
      title?: string;
      description?: string;
      deathsNumAffected?: number;
      deathsNumAtRisk?: number;
      seriousNumAffected?: number;
      seriousNumAtRisk?: number;
      otherNumAffected?: number;
      otherNumAtRisk?: number;
    };
    Mesh: {
      id?: string;
      term?: string;
    };
    FlowGroup: {
      id?: string;
      title?: string;
      description?: string;
    };
    MeasureAnalysis: {
      paramType?: string;
      paramValue?: string;
      dispersionType?: components["schemas"]["AnalysisDispersionType"];
      dispersionValue?: string;
      statisticalMethod?: string;
      statisticalComment?: string;
      pValue?: string;
      pValueComment?: string;
      ciNumSides?: components["schemas"]["ConfidenceIntervalNumSides"];
      ciPctValue?: string;
      ciLowerLimit?: string;
      ciUpperLimit?: string;
      ciLowerLimitComment?: string;
      ciUpperLimitComment?: string;
      estimateComment?: string;
      testedNonInferiority?: boolean;
      nonInferiorityType?: components["schemas"]["NonInferiorityType"];
      nonInferiorityComment?: string;
      otherAnalysisDescription?: string;
      groupDescription?: string;
      groupIds?: string[];
    };
    AdverseEvent: {
      term?: string;
      organSystem?: string;
      sourceVocabulary?: string;
      assessmentType?: components["schemas"]["EventAssessment"];
      notes?: string;
      stats?: components["schemas"]["EventStats"][];
    };
    Retraction: {
      pmid?: string;
      source?: string;
    };
    Denom: {
      units?: string;
      counts?: components["schemas"]["DenomCount"][];
    };
    FlowPeriod: {
      title?: string;
      milestones?: components["schemas"]["FlowMilestone"][];
      dropWithdraws?: components["schemas"]["DropWithdraw"][];
    };
    MeasureGroup: {
      id?: string;
      title?: string;
      description?: string;
    };
    MeasureClass: {
      title?: string;
      denoms?: components["schemas"]["Denom"][];
      categories?: components["schemas"]["MeasureCategory"][];
    };
    BrowseBranch: {
      abbrev?: string;
      name?: string;
    };
    BaselineMeasure: {
      title?: string;
      description?: string;
      populationDescription?: string;
      paramType?: components["schemas"]["MeasureParam"];
      dispersionType?: components["schemas"]["MeasureDispersionType"];
      unitOfMeasure?: string;
      calculatePct?: boolean;
      denomUnitsSelected?: string;
      denoms?: components["schemas"]["Denom"][];
      classes?: components["schemas"]["MeasureClass"][];
    };
    LargeDoc: {
      typeAbbrev?: string;
      hasProtocol?: boolean;
      hasSap?: boolean;
      hasIcf?: boolean;
      label?: string;
      /** Format: date */
      date?: string;
      uploadDate?: components["schemas"]["DateTimeMinutes"];
      filename?: string;
      size?: number;
    };
    DropWithdraw: {
      type?: string;
      comment?: string;
      reasons?: components["schemas"]["FlowStats"][];
    };
    DenomCount: {
      groupId?: string;
      value?: string;
    };
    EventStats: {
      groupId?: string;
      numEvents?: number;
      numAffected?: number;
      numAtRisk?: number;
    };
    MeasureCategory: {
      title?: string;
      measurements?: components["schemas"]["Measurement"][];
    };
    FlowMilestone: {
      type?: string;
      comment?: string;
      achievements?: components["schemas"]["FlowStats"][];
    };
    FlowStats: {
      groupId?: string;
      comment?: string;
      numSubjects?: string;
      numUnits?: string;
    };
    Measurement: {
      groupId?: string;
      value?: string;
      spread?: string;
      lowerLimit?: string;
      upperLimit?: string;
      comment?: string;
    };
    /** @enum {string} */
    Status: "ACTIVE_NOT_RECRUITING" | "COMPLETED" | "ENROLLING_BY_INVITATION" | "NOT_YET_RECRUITING" | "RECRUITING" | "SUSPENDED" | "TERMINATED" | "WITHDRAWN" | "AVAILABLE" | "NO_LONGER_AVAILABLE" | "TEMPORARILY_NOT_AVAILABLE" | "APPROVED_FOR_MARKETING" | "WITHHELD" | "UNKNOWN";
    /** @enum {string} */
    StudyType: "EXPANDED_ACCESS" | "INTERVENTIONAL" | "OBSERVATIONAL";
    /** @enum {string} */
    Phase: "NA" | "EARLY_PHASE1" | "PHASE1" | "PHASE2" | "PHASE3" | "PHASE4";
    /** @enum {string} */
    Sex: "FEMALE" | "MALE" | "ALL";
    /** @enum {string} */
    StandardAge: "CHILD" | "ADULT" | "OLDER_ADULT";
    /** @enum {string} */
    SamplingMethod: "PROBABILITY_SAMPLE" | "NON_PROBABILITY_SAMPLE";
    /** @enum {string} */
    IpdSharing: "YES" | "NO" | "UNDECIDED";
    /** @enum {string} */
    IpdSharingInfoType: "STUDY_PROTOCOL" | "SAP" | "ICF" | "CSR" | "ANALYTIC_CODE";
    /** @enum {string} */
    OrgStudyIdType: "NIH" | "FDA" | "VA" | "CDC" | "AHRQ" | "SAMHSA";
    /** @enum {string} */
    SecondaryIdType: "NIH" | "FDA" | "VA" | "CDC" | "AHRQ" | "SAMHSA" | "OTHER_GRANT" | "EUDRACT_NUMBER" | "REGISTRY" | "OTHER";
    /** @enum {string} */
    AgencyClass: "NIH" | "FED" | "OTHER_GOV" | "INDIV" | "INDUSTRY" | "NETWORK" | "AMBIG" | "OTHER" | "UNKNOWN";
    /** @enum {string} */
    ExpandedAccessStatus: "AVAILABLE" | "NO_LONGER_AVAILABLE" | "TEMPORARILY_NOT_AVAILABLE" | "APPROVED_FOR_MARKETING";
    /** @enum {string} */
    DateType: "ACTUAL" | "ESTIMATED";
    /** @enum {string} */
    ResponsiblePartyType: "SPONSOR" | "PRINCIPAL_INVESTIGATOR" | "SPONSOR_INVESTIGATOR";
    /** @enum {string} */
    DesignAllocation: "RANDOMIZED" | "NON_RANDOMIZED" | "NA";
    /** @enum {string} */
    InterventionalAssignment: "SINGLE_GROUP" | "PARALLEL" | "CROSSOVER" | "FACTORIAL" | "SEQUENTIAL";
    /** @enum {string} */
    PrimaryPurpose: "TREATMENT" | "PREVENTION" | "DIAGNOSTIC" | "ECT" | "SUPPORTIVE_CARE" | "SCREENING" | "HEALTH_SERVICES_RESEARCH" | "BASIC_SCIENCE" | "DEVICE_FEASIBILITY" | "OTHER";
    /** @enum {string} */
    ObservationalModel: "COHORT" | "CASE_CONTROL" | "CASE_ONLY" | "CASE_CROSSOVER" | "ECOLOGIC_OR_COMMUNITY" | "FAMILY_BASED" | "DEFINED_POPULATION" | "NATURAL_HISTORY" | "OTHER";
    /** @enum {string} */
    DesignTimePerspective: "RETROSPECTIVE" | "PROSPECTIVE" | "CROSS_SECTIONAL" | "OTHER";
    /** @enum {string} */
    BioSpecRetention: "NONE_RETAINED" | "SAMPLES_WITH_DNA" | "SAMPLES_WITHOUT_DNA";
    /** @enum {string} */
    EnrollmentType: "ACTUAL" | "ESTIMATED";
    /** @enum {string} */
    ArmGroupType: "EXPERIMENTAL" | "ACTIVE_COMPARATOR" | "PLACEBO_COMPARATOR" | "SHAM_COMPARATOR" | "NO_INTERVENTION" | "OTHER";
    /** @enum {string} */
    InterventionType: "BEHAVIORAL" | "BIOLOGICAL" | "COMBINATION_PRODUCT" | "DEVICE" | "DIAGNOSTIC_TEST" | "DIETARY_SUPPLEMENT" | "DRUG" | "GENETIC" | "PROCEDURE" | "RADIATION" | "OTHER";
    /** @enum {string} */
    ContactRole: "STUDY_CHAIR" | "STUDY_DIRECTOR" | "PRINCIPAL_INVESTIGATOR" | "SUB_INVESTIGATOR" | "CONTACT";
    /** @enum {string} */
    OfficialRole: "STUDY_CHAIR" | "STUDY_DIRECTOR" | "PRINCIPAL_INVESTIGATOR" | "SUB_INVESTIGATOR";
    /** @enum {string} */
    RecruitmentStatus: "ACTIVE_NOT_RECRUITING" | "COMPLETED" | "ENROLLING_BY_INVITATION" | "NOT_YET_RECRUITING" | "RECRUITING" | "SUSPENDED" | "TERMINATED" | "WITHDRAWN" | "AVAILABLE";
    /** @enum {string} */
    ReferenceType: "BACKGROUND" | "RESULT" | "DERIVED";
    /** @enum {string} */
    MeasureParam: "GEOMETRIC_MEAN" | "GEOMETRIC_LEAST_SQUARES_MEAN" | "LEAST_SQUARES_MEAN" | "LOG_MEAN" | "MEAN" | "MEDIAN" | "NUMBER" | "COUNT_OF_PARTICIPANTS" | "COUNT_OF_UNITS";
    /** @enum {string} */
    MeasureDispersionType: "NA" | "STANDARD_DEVIATION" | "STANDARD_ERROR" | "INTER_QUARTILE_RANGE" | "FULL_RANGE" | "CONFIDENCE_80" | "CONFIDENCE_90" | "CONFIDENCE_95" | "CONFIDENCE_975" | "CONFIDENCE_99" | "CONFIDENCE_OTHER" | "GEOMETRIC_COEFFICIENT";
    /** @enum {string} */
    OutcomeMeasureType: "PRIMARY" | "SECONDARY" | "OTHER_PRE_SPECIFIED" | "POST_HOC";
    /** @enum {string} */
    ReportingStatus: "NOT_POSTED" | "POSTED";
    /** @enum {string} */
    EventAssessment: "NON_SYSTEMATIC_ASSESSMENT" | "SYSTEMATIC_ASSESSMENT";
    /** @enum {string} */
    AgreementRestrictionType: "LTE60" | "GT60" | "OTHER";
    /** @enum {string} */
    BrowseLeafRelevance: "LOW" | "HIGH";
    /** @enum {string} */
    DesignMasking: "NONE" | "SINGLE" | "DOUBLE" | "TRIPLE" | "QUADRUPLE";
    /** @enum {string} */
    WhoMasked: "PARTICIPANT" | "CARE_PROVIDER" | "INVESTIGATOR" | "OUTCOMES_ASSESSOR";
    /** @enum {string} */
    AnalysisDispersionType: "STANDARD_DEVIATION" | "STANDARD_ERROR_OF_MEAN";
    /** @enum {string} */
    ConfidenceIntervalNumSides: "ONE_SIDED" | "TWO_SIDED";
    /** @enum {string} */
    NonInferiorityType: "SUPERIORITY" | "NON_INFERIORITY" | "EQUIVALENCE" | "OTHER" | "NON_INFERIORITY_OR_EQUIVALENCE" | "SUPERIORITY_OR_OTHER" | "NON_INFERIORITY_OR_EQUIVALENCE_LEGACY" | "SUPERIORITY_OR_OTHER_LEGACY";
    /** @enum {string} */
    UnpostedEventType: "RESET" | "RELEASE" | "UNRELEASE";
    /** @enum {string} */
    ViolationEventType: "VIOLATION_IDENTIFIED" | "CORRECTION_CONFIRMED" | "PENALTY_IMPOSED";
    GeoPoint: {
      lat: number;
      lon: number;
    };
    FieldValuesStatsList: components["schemas"]["FieldValuesStats"][];
    FieldValuesStats: components["schemas"]["EnumStats"] | components["schemas"]["StringStats"] | components["schemas"]["DateStats"] | components["schemas"]["IntegerStats"] | components["schemas"]["NumberStats"] | components["schemas"]["BooleanStats"];
    /**
     * Array of studies
     * @description `study` field values of type `markup` are in markdown format.
     */
    StudyList: components["schemas"]["Study"][];
    /** @description Study objects in csv file */
    StudiesCsv: string;
    /** @description Study objects as files in zip archive */
    StudiesZip: string;
    /** @description Study in FHIR JSON format */
    StudyFhir: Record<string, never>;
    /** @description Date in `yyyy`, `yyyy-MM`, or `yyyy-MM-dd` format */
    PartialDate: string;
    /** @description Date and time in `yyyy-MM-dd'T'HH:mm` format */
    DateTimeMinutes: string;
    /** @description A text message describing an error */
    errorMessage: string;
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Studies
   * @description Returns data of studies matching query and filter parameters. The studies are returned page by page.
   * If response contains `nextPageToken`, use its value in `pageToken` to get next page.
   * The last page will not contain `nextPageToken`. A page may have empty `studies` array.
   * Request for each subsequent page **must** have the same parameters as for the first page, except
   * `countTotal`, `pageSize`, and `pageToken` parameters.
   *
   * If neither queries nor filters are set, all studies will be returned.
   * If any query parameter contains only NCT IDs (comma- and/or space-separated), filters are ignored.
   *
   * `query.*` parameters are in [Essie expression syntax](https://classic.clinicaltrials.gov/api/gui/ref/syntax).
   *
   * `filter.*` and `postFilter.*` parameters have same effect as there is no aggregation calculation.
   * Both are available just to simplify applying parameters from search request.
   *
   * Note: When trying JSON format in your browser, do not set too large `pageSize` parameter, if `fields` is
   * unlimited. That may return too much data for the browser to parse and render.
   */
  listStudies: {
    parameters: {
      query?: {
        /**
         * @description Must be one of the following:
         * * `csv`- return CSV table with one page of study data; first page will contain header with column names; available fields are listed on [CSV Download](/csv-download) page
         * * `json`- return JSON with one page of study data; every study object is placed in a separate line; `markup` type fields format depends on `markupFormat` parameter
         */
        format?: "csv" | "json";
        /**
         * @description Format of `markup` type fields:
         * * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format
         * * `legacy`- compatible with classic PRS
         *
         * Applicable only to `json` format.
         */
        markupFormat?: "markdown" | "legacy";
        /** @description "Conditions or disease" query. See "ConditionSearch Area" on [Search Areas](/search-areas#ConditionSearch) for more details. */
        "query.cond"?: string;
        /** @description "Other terms" query. See "BasicSearch Area" on [Search Areas](/search-areas#BasicSearch) for more details. */
        "query.term"?: string;
        /** @description "Location terms" query. See "LocationSearch Area" on [Search Areas](/search-areas#LocationSearch) for more details. */
        "query.locn"?: string;
        /** @description "Title / acronym" query. See "TitleSearch Area" on [Search Areas](/search-areas#TitleSearch) for more details. */
        "query.titles"?: string;
        /** @description "Intervention / treatment" query. See "InterventionSearch Area" on [Search Areas](/search-areas#InterventionSearch) for more details. */
        "query.intr"?: string;
        /** @description "Outcome measure" query. See "OutcomeSearch Area" on [Search Areas](/search-areas#OutcomeSearch) for more details. */
        "query.outc"?: string;
        /** @description "Sponsor / collaborator" query. See "SponsorSearch Area" on [Search Areas](/search-areas#SponsorSearch) for more details. */
        "query.spons"?: string;
        /** @description Searches in "LeadSponsorName" field. See [Study Data Structure](/study-data-structure#LeadSponsorName) for more details. */
        "query.lead"?: string;
        /** @description "Study IDs" query. See "IdSearch Area" on [Search Areas](/search-areas#IdSearch) for more details. */
        "query.id"?: string;
        /** @description See "PatientSearch Area" on [Search Areas](/search-areas#PatientSearch) for more details. */
        "query.patient"?: string;
        /** @description Filter by comma- or pipe-separated list of statuses */
        "filter.overallStatus"?: components["schemas"]["Status"][];
        /**
         * @description Filter by geo-function. Currently only distance function is supported.
         * Format: `distance(latitude,longitude,distance)`
         */
        "filter.geo"?: string;
        /** @description Filter by comma- or pipe-separated list of NCT numbers (a.k.a. ClinicalTrials.gov identifiers) */
        "filter.ids"?: string[];
        /** @description Filter by query in [Essie expression syntax](https://classic.clinicaltrials.gov/api/gui/ref/syntax) */
        "filter.advanced"?: string;
        /** @description Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs */
        "filter.synonyms"?: string[];
        /** @description Filter by comma- or pipe-separated list of statuses */
        "postFilter.overallStatus"?: components["schemas"]["Status"][];
        /**
         * @description Filter by geo-function. Currently only distance function is supported.
         * Format: `distance(latitude,longitude,distance)`
         */
        "postFilter.geo"?: string;
        /** @description Filter by comma- or pipe-separated list of NCT numbers (a.k.a. ClinicalTrials.gov identifiers) */
        "postFilter.ids"?: string[];
        /** @description Filter by query in [Essie expression syntax](https://classic.clinicaltrials.gov/api/gui/ref/syntax) */
        "postFilter.advanced"?: string;
        /** @description Filter by comma- or pipe-separated list of `area`:`synonym_id` pairs */
        "postFilter.synonyms"?: string[];
        /**
         * @description Apply aggregation filters, aggregation counts will not be provided.
         * The value is comma- or pipe-separated list of pairs `filter_id`:`space-separated list of option keys` for the checked options.
         */
        aggFilters?: string;
        /**
         * @description Set proximity factor by distance from `filter.geo` location to the closest [LocationGeoPoint](/study-data-structure#LocationGeoPoint) of a study.
         * Ignored, if `filter.geo` parameter is not set or response contains more than 10,000 studies.
         */
        geoDecay?: string;
        /**
         * @description If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned.
         * Order of the fields does not matter.
         *
         * For `csv` format, specify list of columns. The column names are available on [CSV Download](/csv-download).
         *
         * For `json` format, every list item is either area name, piece name, field name, or special name.
         * If a piece or a field is a branch node, all descendant fields will be included.
         * All area names are available on [Search Areas](/search-areas),
         * the piece and field names â€” on [Data Structure](/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint.
         * There is a special name, `@query`, which expands to all fields queried by search.
         */
        fields?: string[];
        /**
         * @description Comma- or pipe-separated list of sorting options of the studies. The returning studies are not sorted by default for a performance reason.
         * Every list item contains a field/piece name and an optional sort direction (`asc` for ascending or `desc` for descending)
         * after colon character.
         *
         * All piece and field names can be found on [Data Structure](/study-data-structure) and also can be retrieved
         * at `/studies/metadata` endpoint. Currently, only date and numeric fields are allowed for sorting.
         * There is a special "field" `@relevance` to sort by relevance to a search query.
         *
         * Studies missing sort field are always last. Default sort direction:
         * * Date field - `desc`
         * * Numeric field - `asc`
         * * `@relevance` - `desc`
         */
        sort?: string[];
        /**
         * @description Count total number of studies in all pages and return `totalCount` field with first page, if `true`.
         * For CSV, the result can be found in `x-total-count` response header.
         * The parameter is ignored for the subsequent pages.
         */
        countTotal?: boolean;
        /**
         * @description Page size is maximum number of studies to return in response. It does not have to be the same for every page.
         * If not specified or set to 0, the default value will be used. It will be coerced down to  1,000, if greater than that.
         */
        pageSize?: number;
        /**
         * @description Token to get next page. Set it to a `nextPageToken` value returned with the previous page in JSON format.
         * For CSV, it can be found in `x-next-page-token` response header.
         * Do not specify it for first page.
         */
        pageToken?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["PagedStudies"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
    };
  };
  /**
   * Single Study
   * @description Returns data of a single study.
   */
  fetchStudy: {
    parameters: {
      query?: {
        /**
         * @description Must be one of the following:
         * * `csv`- return CSV table; available fields are listed on [CSV Download](/csv-download)
         * * `json`- return JSON object; format of `markup` fields depends on `markupFormat` parameter
         * * `json.zip`- put JSON object into a .json file and download it as zip archive; field values of type `markup` are in [markdown](https://spec.commonmark.org/0.28/) format
         * * `fhir.json` - return FHIR JSON; fields are not customizable
         */
        format?: "csv" | "json" | "json.zip" | "fhir.json";
        /**
         * @description Format of `markup` type fields:
         * * `markdown`- [markdown](https://spec.commonmark.org/0.28/) format
         * * `legacy`- compatible with classic PRS
         *
         * Applicable only to `json` format.
         */
        markupFormat?: "markdown" | "legacy";
        /**
         * @description If specified, must be non-empty comma- or pipe-separated list of fields to return. If unspecified, all fields will be returned.
         * Order of the fields does not matter.
         *
         * For `csv` format, specify list of columns. The column names are available on [CSV Download](/csv-download).
         *
         * For `json` and `json.zip` formats, every list item is either area name, piece name, or field name.
         * If a piece or a field is a branch node, all descendant fields will be included.
         * All area names are available on [Search Areas](/search-areas),
         * the piece and field names - on [Data Structure](/study-data-structure) and also can be retrieved at `/studies/metadata` endpoint.
         *
         * For `fhir.json` format, all available fields are returned and this parameter must be unspecified.
         */
        fields?: string[];
      };
      path: {
        /** @description NCT Number of a study */
        nctId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "text/csv": components["schemas"]["StudiesCsv"];
          "application/json": components["schemas"]["Study"];
          "application/zip": components["schemas"]["StudiesZip"];
          "application/fhir+json": components["schemas"]["StudyFhir"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
    };
  };
  /**
   * Data Model Fields
   * @description Returns study data model fields.
   */
  studiesMetadata: {
    parameters: {
      query?: {
        /** @description Include indexed-only fields, if `true` */
        includeIndexedOnly?: boolean;
        /** @description Include fields available only in historic data, if `true` */
        includeHistoricOnly?: boolean;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["FieldNodeList"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
    };
  };
  /**
   * Search Areas
   * @description Search Docs and their Search Areas.
   */
  searchAreas: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SearchDocumentList"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
    };
  };
  /**
   * Enums
   * @description Returns enumeration types and their values.
   *
   * Every item of the returning array represents enum type and contains the following properties:
   * * `type` - enum type name
   * * `pieces` - array of names of all data pieces having the enum type
   * * `values` - all available values of the enum; every item contains the following properties:
   *   * `value` - data value
   *   * `legacyValue` - data value in legacy API
   *   * `exceptions` - map from data piece name to legacy value when different from `legacyValue`
   *     (some data pieces had special enum values in legacy API)
   */
  enums: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["EnumInfoList"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
    };
  };
  /**
   * Study Sizes
   * @description Statistics of study JSON sizes.
   */
  sizeStats: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GzipStats"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
    };
  };
  /**
   * Field Values
   * @description Value statistics of the study leaf fields.
   */
  fieldValuesStats: {
    parameters: {
      query?: {
        /** @description Filter by field types */
        types?: components["schemas"]["FieldStatsType"][];
        /**
         * @description Filter by piece names or field paths of leaf fields.
         * See [Data Structure](/study-data-structure) for the available values.
         *
         * If specified, must be non-empty comma- or pipe-separated list of fields to return.
         */
        fields?: string[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["FieldValuesStatsList"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
    };
  };
  /**
   * List Field Sizes
   * @description Sizes of list/array fields.
   *
   * To search studies by a list field size, use `AREA[FieldName:size]` search operator.
   * For example, [AREA\[Phase:size\] 2](https://clinicaltrials.gov/search?term=AREA%5BPhase:size%5D%202)
   * query finds studies with 2 phases.
   */
  listFieldSizesStats: {
    parameters: {
      query?: {
        /**
         * @description Filter by piece names or field paths of leaf fields.
         * See [Data Structure](/study-data-structure) for the available values.
         *
         * If specified, must be non-empty comma- or pipe-separated list of fields to return.
         * If unspecified, all available stats will be returned.
         */
        fields?: string[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListSizesList"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
    };
  };
  /**
   * Version
   * @description API and data versions.
   *
   * API version follows [Semantic Versioning 2.0.0 Schema](https://semver.org/spec/v2.0.0.html).
   * Data version is UTC timestamp in `yyyy-MM-dd'T'HH:mm:ss` format.
   */
  version: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Version"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "text/plain": components["schemas"]["errorMessage"];
        };
      };
    };
  };
}
